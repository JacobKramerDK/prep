import { OpenAIService } from '../src/main/services/openai-service'
import { BriefGenerationRequest } from '../src/shared/types/brief'
import { Meeting } from '../src/shared/types/meeting'

// Mock OpenAI
jest.mock('openai', () => {
  return {
    __esModule: true,
    default: jest.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: jest.fn().mockResolvedValue({
            choices: [{
              message: {
                content: '# Meeting Brief\n\nThis is a test brief generated by AI.'
              }
            }]
          })
        }
      },
      models: {
        list: jest.fn().mockResolvedValue({ data: [] })
      }
    }))
  }
})

describe('OpenAIService Security Fixes', () => {
  let service: OpenAIService

  beforeEach(() => {
    service = new OpenAIService('test-api-key')
  })

  test('should generate cryptographically secure UUIDs for brief IDs', async () => {
    const request: BriefGenerationRequest = {
      meetingId: 'test-meeting-1',
      userContext: 'Test context'
    }

    const meeting: Meeting = {
      id: 'test-meeting-1',
      title: 'Test Meeting',
      startDate: new Date(),
      endDate: new Date(),
      isAllDay: false,
      source: 'ics'
    }

    const brief1 = await service.generateMeetingBrief(request, meeting)
    const brief2 = await service.generateMeetingBrief(request, meeting)

    // UUIDs should be different
    expect(brief1.id).not.toBe(brief2.id)
    
    // UUIDs should follow UUID v4 format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
    expect(brief1.id).toMatch(uuidRegex)
    expect(brief2.id).toMatch(uuidRegex)
    
    // Should not contain predictable patterns from Math.random()
    expect(brief1.id).not.toContain('brief-')
    expect(brief1.id).not.toMatch(/\d{13}/) // No timestamp patterns
  })

  test('should not expose sensitive information in error logs', async () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation()
    
    // Create service that will fail
    const failingService = new OpenAIService('invalid-key')
    
    // Mock OpenAI to throw an error that might contain API key
    const mockError = new Error('Invalid API key: sk-test-key-should-not-be-logged')
    jest.mocked(failingService['client']!.chat.completions.create).mockRejectedValue(mockError)

    const request: BriefGenerationRequest = {
      meetingId: 'test-meeting-1',
      userContext: 'Test context'
    }

    const meeting: Meeting = {
      id: 'test-meeting-1',
      title: 'Test Meeting',
      startDate: new Date(),
      endDate: new Date(),
      isAllDay: false,
      source: 'ics'
    }

    try {
      await failingService.generateMeetingBrief(request, meeting)
    } catch (error) {
      // Expected to throw
    }

    // Verify that console.error was called with sanitized message
    expect(consoleSpy).toHaveBeenCalledWith('OpenAI API error:', mockError.message)
    
    // Verify the full error object (which might contain sensitive data) was not logged
    expect(consoleSpy).not.toHaveBeenCalledWith('OpenAI API error:', mockError)

    consoleSpy.mockRestore()
  })
})
